---
layout: post
title: 'spoj2798 QTREE3 LCT'
date: 2014-08-25 15:40
tags: [数据结构,spoj]
---
就是个LCT。树链剖分应该也可以做，不过肯定没LCT方便。这里LCT还用不着换根，只需要`expose()`操作。
由于spoj用的是又老又旧又渣的P3测的，这种大规模输入不加读入优化就是过不了。
于是直接使用终极方法——`fread()`，效果显著，83.33->AC。
<!--more-->

```c++
#include <cstdio>
#include <cstring>
#include <cctype>
#include <algorithm>

using namespace std;

const int MaxN = 100010;

int n,m;
int col[MaxN];

struct Edge{
	int v;
	Edge *nxt;
}pool_e[MaxN<<1],*tail_e=pool_e,*g[MaxN];

struct Node{
	int id,lid;
	Node *lc,*rc,*fa,*path_fa;
	void update(){
		lid=col[id] ? id : -1;
		if(lc && ~lc->lid) lid=lc->lid;
		if(rc && ~rc->lid && !~lid) lid=rc->lid;
	}
	void zig(){
		Node *p=lc;
		p->rc=((lc=p->rc) ? lc->fa=this : this);
		if(p->fa=fa) fa->lc==this ? fa->lc=p : fa->rc=p;
		fa=p;swap(path_fa,p->path_fa);
		update();p->update();
	}
	void zag(){
		Node *p=rc;
		p->lc=((rc=p->lc) ? rc->fa=this : this);
		if(p->fa=fa) fa->lc==this ? fa->lc=p : fa->rc=p;
		fa=p;swap(path_fa,p->path_fa);
		update();p->update();
	}
}pool[MaxN],*tail=pool,*pos[MaxN];

inline void splay(Node *p){
	while(p->fa){
		if(p->fa->fa){
			if(p->fa==p->fa->fa->lc){
				if(p==p->fa->lc) p->fa->fa->zig(),p->fa->zig();
				else p->fa->zag(),p->fa->zig();
			}
			else{
				if(p==p->fa->lc) p->fa->zig(),p->fa->zag();
				else p->fa->fa->zag(),p->fa->zag();
			}
		}
		else{
			if(p==p->fa->lc) p->fa->zig();
			else p->fa->zag();
		}
	}
	p->update();
}

inline void expose(int u){
	Node *p=pos[u],*q;
	splay(p);
	if(q=p->rc) q->fa=0,q->path_fa=p;
	p->rc=0;p->update();
	while(q=p->path_fa){
		splay(q);
		if(q->rc) q->rc->fa=0,q->rc->path_fa=q;
		(q->rc=p)->fa=q;p->path_fa=0;q->update();
		splay(p);
	}
}
inline void make_edge(int u,int v){
	tail_e->v=v;tail_e->nxt=g[u];g[u]=tail_e++;
	tail_e->v=u;tail_e->nxt=g[v];g[v]=tail_e++;
}

Node *dfs(int u){
	pos[u]=tail++;
	pos[u]->id=u;pos[u]->update();
	for(Edge *p=g[u];p;p=p->nxt) if(!pos[p->v])
		dfs(p->v)->path_fa=pos[u];
	return pos[u];
}

char buf[3000000],*cur_ptr;
inline void InputInit(){
	fread(buf,sizeof(char),sizeof(buf),stdin);
	cur_ptr=buf;
}

inline int getInt(){
	int x=0;
	for(;!isdigit(*cur_ptr);cur_ptr++);
	for(;isdigit(*cur_ptr);cur_ptr++) x=x*10+ *cur_ptr -'0';
	return x;
}
int main()
{
#ifdef __TEST
	freopen("QTREE3.in","r",stdin);
	freopen("QTREE3.out","w",stdout);
#endif
	InputInit();
	n=getInt(),m=getInt();
	for(int i=1;i<n;i++){
		int u,v;
		u=getInt();v=getInt();
		make_edge(u,v);
	}
	dfs(1);
	for(int i=1;i<=m;i++){
		int op,u;
		op=getInt(),u=getInt();
		if(!op) expose(u),col[u]=!col[u],pos[u]->update();
		else expose(u),printf("%d\n",pos[u]->lid);
	}
	return 0;
}
```

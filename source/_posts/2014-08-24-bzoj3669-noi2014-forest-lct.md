---
layout: post
title: 'bzoj3669 noi2014 forest LCT'
date: 2014-08-24 16:43
tags: [数据结构,noi,bzoj]
---
noi2014 D1 T2。~~由于bzoj挂了，暂时只能交到wikioi上面去了。~~
UPD : 已经交至bzoj，题号3669。wikioi3314。
主要做法是对于所有边，将自环去掉，然后按a从小到大排序。之后要求能够维护n个点关于b的最小生成森林，并能够动态查询1到n路径上b的最大值。
这显然是可以用LCT来处理的。只不过需要进行一些转化。
由于LCT对于点的处理非常方便，而对于边的处理比较无力，因此对于每一条边，建一个虚点，这样边权就转化成点权，好处理多了。
<!--more-->
```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <utility>
#include <vector>

using namespace std;

typedef pair<int,int> PII;
typedef pair<PII,PII> PPP;

const int MaxN = 100010;

struct Node{
	int id,w,maxw,maxid,rev;
	Node *lc,*rc,*fa,*path_fa;
	void update(){
		maxw=w;maxid=id;
		lc && lc->maxw>maxw ? maxw=lc->maxw,maxid=lc->maxid : 0;
		rc && rc->maxw>maxw ? maxw=rc->maxw,maxid=rc->maxid : 0;
	}
	void flip(){rev^=1;swap(lc,rc);}
	void sink(){
		if(rev){
			if(lc) lc->flip();
			if(rc) rc->flip();
			rev=0;
		}
	}
	void zig(){
		Node *p=lc;
		p->rc=((lc=p->rc) ? lc->fa=this : this);
		if(p->fa=fa) fa->lc==this ? fa->lc=p : fa->rc=p;
		fa=p;swap(path_fa,p->path_fa);
		update();p->update();
	}
	void zag(){
		Node *p=rc;
		p->lc=((rc=p->lc) ? rc->fa=this : this);
		if(p->fa=fa) fa->lc==this ? fa->lc=p : fa->rc=p;
		fa=p;swap(path_fa,p->path_fa);
		update();p->update();
	}
}pool[MaxN],*pos[MaxN];

int st[MaxN],u[MaxN],v[MaxN],w[MaxN],tail,upper;

inline void init(int n){for(int i=1;i<MaxN;i++) (pos[i]=pool+i)->id=i;tail=n;}
inline int newNode(int _u=0,int _v=0,int _w=0){
	int num=(upper ? st[upper--] : ++tail);
	Node *p=pool+num;
	p->rev=0;p->maxid=num;p->maxw=p->w=_w;
	p->lc=p->rc=p->fa=p->path_fa=0;
	u[num]=_u,v[num]=_v;w[num]=_w;
	return num;	
}
inline void recycle(int num){st[++upper]=num;}

void splay(Node *p){
	p->sink();
	while(p->fa){
		if(p->fa->fa){
			p->fa->fa->sink();
			p->fa->sink();p->sink();
			if(p->fa==p->fa->fa->lc){
				if(p==p->fa->lc) p->fa->fa->zig(),p->fa->zig();
				else p->fa->zag(),p->fa->zig();
			}
			else{
				if(p==p->fa->lc) p->fa->zig(),p->fa->zag();
				else p->fa->fa->zag(),p->fa->zag();
			}
		}
		else{
			p->fa->sink();p->sink();
			if(p==p->fa->lc) p->fa->zig();
			else p->fa->zag();
		}
	}
	p->update();
}

void expose(int u){
	Node *p=pos[u],*q;
	splay(p);
	if(q=p->rc) q->fa=0,q->path_fa=p;
	p->rc=0;p->update();
	while(q=p->path_fa){
		splay(q);
		if(q->rc) q->rc->fa=0,q->rc->path_fa=q;
		(q->rc=p)->fa=q;p->path_fa=0;q->update();
		splay(p);
	}
}

void make_root(int u){
	Node *p=pos[u];
	expose(u);
	if(p->lc) p->lc->fa=0,p->lc->path_fa=p,p->lc->flip();
	p->lc=0;p->update();
}

void cut(int u,int v){
	Node *p=pos[v];
	make_root(u);expose(v);
	if(p->lc) p->lc->fa=0;
	p->lc=0;p->update();
}

void join(int u,int v){
	make_root(v);expose(u);
	pos[v]->path_fa=pos[u];
	expose(v);	
}

int getRoot(int u){
	Node *p=pos[u];
	expose(u);
	for(p->sink();p->lc;p=p->lc,p->sink());
	splay(p);
	return p->id;
}

int getMax(int u,int v){
	if(getRoot(u)!=getRoot(v)) return 0;
	make_root(u);expose(v);
	return pos[v]->maxid;
}

int n,m,ans=0x7fffffff;
vector<PPP> g;

int main()
{
#ifdef __TEST
	freopen("forest.in","r",stdin);
	freopen("forest.out","w",stdout);
#endif
	scanf("%d%d",&n,&m);
	init(n);
	for(int i=1;i<=m;i++){
		int u,v,a,b;
		scanf("%d%d%d%d",&u,&v,&a,&b);
		if(u!=v) g.push_back(PPP(PII(a,b),PII(u,v)));
	}
	sort(g.begin(),g.end());
	for(int i=0;i<g.size();i++){
		int p=getMax(g[i].second.first,g[i].second.second);
		if(!p || p && w[p]>g[i].first.second){
			if(p) cut(u[p],p),cut(v[p],p),recycle(p);
			p=newNode(g[i].second.first,g[i].second.second,g[i].first.second);
			join(u[p],p),join(v[p],p);
			p=getMax(1,n);
			if(p) ans=min(ans,w[p]+g[i].first.first);
		}
	}
	printf("%d\n",ans==0x7fffffff ? -1 : ans);
	return 0;
}
```

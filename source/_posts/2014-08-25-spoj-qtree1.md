---
layout: post
title: 'spoj375 QTREE1 树链剖分'
date: 2014-08-25 10:07
tags: [数据结构,spoj]
---
spoj上的test code其实是QTREE，这里由于是套题，就写做QTREE1了。
裸树链剖分。不过点的编号可能不在1-n中，因此需要离散化。此外由于是多case题，要注意哪些东西必须要初始化。

<!--more-->
```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int MaxN = 10010;

struct Edge{
	int v,c;
	Edge *nxt;
}pool_e[MaxN<<1],*tail_e,*g[MaxN];
int n;
int u[MaxN],v[MaxN],c[MaxN];

struct Node{
	int l,r,mid;
	int maxt;
	Node *lc,*rc;
	void update(){maxt=max(lc->maxt,rc->maxt);}
}pool[MaxN << 2],*tail,*rt;

inline void make_edge(int u,int v,int c){
	tail_e->v=v;tail_e->c=c;tail_e->nxt=g[u];g[u]=tail_e++;
	tail_e->v=u;tail_e->c=c;tail_e->nxt=g[v];g[v]=tail_e++;
}

inline void ckmax(int &a,int b){b>a ? a=b : 0;}

int a[MaxN];
int top[MaxN],fa[MaxN],h[MaxN],size[MaxN],num[MaxN],nxt[MaxN],cnt;
int mapp[MaxN<<1],last;
char op[10];

void dfs(){
	static int q[MaxN],l,r,u;
	for(h[q[l=r=1]=1]=1;l<=r;l++)
		for(Edge *p=g[q[l]];p;p=p->nxt) if(!h[p->v])
			fa[p->v]=q[l],h[q[++r]=p->v]=h[q[l]]+1;
	for(int i=r;i;i--){
		size[u=q[i]]=1;
		for(Edge *p=g[u];p;p=p->nxt) if(fa[p->v]==u)
			size[u]+=size[size[p->v]>size[nxt[u]] ? nxt[u]=p->v : p->v];
	}
	top[1]=1;
	for(q[l=r=1]=1;l<=r;l++){
		num[u=q[l]]=++cnt;
		if(!nxt[u]) continue;
		top[q[l--]=nxt[u]]=top[u];
		for(Edge *p=g[u];p;p=p->nxt) if(p->v!=nxt[u] && fa[p->v]==u)
			top[q[++r]=p->v]=p->v;
	}
}

void build(int l,int r,Node *&rt){
	(rt=tail++)->l=l;rt->r=r;rt->mid=l+r >> 1;
	if(l==r) rt->maxt=a[l];
	else{
		build(l,rt->mid,rt->lc);
		build(rt->mid+1,r,rt->rc);
		rt->update();
	}
}

void modify(int x,int dt,Node *rt){
	if(rt->l==rt->r) rt->maxt=dt;
	else{
		if(x<=rt->mid) modify(x,dt,rt->lc);
		else modify(x,dt,rt->rc);
		rt->update();
	}
}

int query(int l,int r,Node *rt){
	if(l>r) return 0;
	if(l<=rt->l && r>=rt->r) return rt->maxt;
	else{
		int res=0;
		if(l<=rt->mid) ckmax(res,query(l,r,rt->lc));
		if(r> rt->mid) ckmax(res,query(l,r,rt->rc));
		return res;
	}
}

inline int Query(int u,int v){
	int res=0;
	while(top[u]!=top[v]){
		if(h[top[u]]<h[top[v]]) swap(u,v);
		ckmax(res,query(num[top[u]],num[u],rt));
		u=fa[top[u]];
	}
	if(h[u]>h[v]) swap(u,v);
	if(u!=v) ckmax(res,query(num[u]+1,num[v],rt));
	return res;
}
int main()
{
	int T;
	for(scanf("%d",&T);T--;){
		scanf("%d",&n);
		tail_e=pool_e;tail=pool;rt=0;
		memset(g,0,sizeof(g));memset(h,0,sizeof(h));
		memset(a,0,sizeof(a));memset(nxt,0,sizeof(nxt));
		cnt=last=0;
		for(int i=1;i<n;i++)
			scanf("%d%d%d",&u[i],&v[i],&c[i]),
			mapp[++last]=u[i],mapp[++last]=v[i];
		sort(mapp+1,mapp+1+last);
		last=unique(mapp+1,mapp+last+1)-mapp-1;
		for(int i=1;i<n;i++)
			u[i]=lower_bound(mapp+1,mapp+last+1,u[i])-mapp,
			v[i]=lower_bound(mapp+1,mapp+last+1,v[i])-mapp,
			make_edge(u[i],v[i],c[i]);
		dfs();
		for(int i=1;i<n;i++){
			if(u[i]!=fa[v[i]]) swap(u[i],v[i]);
			a[num[v[i]]]=c[i];
		}
		build(1,n,rt);
		for(scanf("%s",op);op[0]!='D';scanf("%s",op)){
			int a,b;
			scanf("%d%d",&a,&b);
			if(op[0]=='C') modify(num[v[a]],b,rt);
			else{
				a=lower_bound(mapp+1,mapp+last+1,a)-mapp;
				b=lower_bound(mapp+1,mapp+last+1,b)-mapp;
				printf("%d\n",Query(a,b));
			}
		}
	}
	return 0;
}
```

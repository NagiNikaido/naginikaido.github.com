---
layout: post
title: 'spoj16580 QTREE7 LCT'
date: 2014-08-30 16:17
tags: [数据结构,spoj]
---
LCT。总时长3.62s。
在LCT中的每个节点上挂两个`multiset<int>`，分别来存储所有虚边的黑白信息。同时在节点上维护子树的最左最右端的颜色，和左右连续同色段中的最大w。所有的操作和询问只需要一个`expose`就可以几乎无副作用地进行，非常方便。总时间复杂度$O(n+mlog_2^2n)$。
这题看起来也可以用树链剖分解决——差不多就是QTREE5+QTREE6。剖分以后，对于每条链用线段树维护区间最大值，每个点上用堆来存储从轻儿子收集的信息，每条链上开3个`map`来求极长同色连续段。总时间复杂度差不多是$O(nlog_2n+mlog_2^2n)$。
可以想象的是，这种做法会非常麻烦，时空间的常数都不会太小。在LCT面前，完败。
也许QTREE456都能用LCT做？

<!--more-->

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>

using namespace std;

const int MaxN = 100010;
const int INF = -0x3f3f3f3f;

struct Edge{
	int v;
	Edge *nxt;
}pool_e[MaxN<<1],*tail_e=pool_e,*g[MaxN];

inline void make_edge(int u,int v){
	tail_e->v=v;tail_e->nxt=g[u];g[u]=tail_e++;
	tail_e->v=u;tail_e->nxt=g[v];g[v]=tail_e++;
}

int n,m;
int w[MaxN],col[MaxN];

struct Node{
	int id,maxl,maxr,lco,rco,el[2];
	multiset<int> stein[2];
	Node *lc,*rc,*fa,*path_fa;
	void update(){
		lco= lc ? lc->lco : col[id];
		rco= rc ? rc->rco : col[id];
		el[0]=(lc ? lc->el[0] : 0)+(rc ? rc->el[0] : 0)+(col[id]==0);
		el[1]=(lc ? lc->el[1] : 0)+(rc ? rc->el[1] : 0)+(col[id]==1);
		int ml=max(w[id],max(*stein[col[id]].rbegin(),lc && col[id]==lc->rco ? lc->maxr	: INF));
		int mr=max(w[id],max(*stein[col[id]].rbegin(),rc && col[id]==rc->lco ? rc->maxl : INF));
		maxl=lc ? lc->maxl : INF;
		maxr=rc ? rc->maxr : INF;
		if(lco==col[id] && (!lc || !lc->el[!col[id]])) maxl=max(maxl,mr);
		if(rco==col[id] && (!rc || !rc->el[!col[id]])) maxr=max(maxr,ml);
	}
	void zig(){
		Node *p=lc;
		p->rc=((lc=p->rc) ? lc->fa=this : this);
		if(p->fa=fa) fa->lc==this ? fa->lc=p : fa->rc=p;
		fa=p;swap(path_fa,p->path_fa);
		update();p->update();
	}
	void zag(){
		Node *p=rc;
		p->lc=((rc=p->lc) ? rc->fa=this : this);
		if(p->fa=fa) fa->lc==this ? fa->lc=p : fa->rc=p;
		fa=p;swap(path_fa,p->path_fa);
		update();p->update();
	}
}pool[MaxN],*tail=pool,*pos[MaxN];

void splay(Node *p){
	while(p->fa){
		if(p->fa->fa){
			if(p->fa==p->fa->fa->lc){
				if(p==p->fa->lc) p->fa->fa->zig(),p->fa->zig();
				else p->fa->zag(),p->fa->zig();
			}
			else{
				if(p==p->fa->lc) p->fa->zig(),p->fa->zag();
				else p->fa->fa->zag(),p->fa->zag();
			}
		}
		else{
			if(p==p->fa->lc) p->fa->zig();
			else p->fa->zag();
		}
	}
	p->update();
}

void expose(int u){
	Node *p=pos[u],*q;
	splay(p);
	if(q=p->rc) q->path_fa=p,q->fa=0,p->stein[q->lco].insert(q->maxl);
	p->rc=0;p->update();
	for(q=p->path_fa;q;q=p->path_fa){
		splay(q);
		if(q->rc) q->rc->path_fa=q,q->rc->fa=0,q->stein[q->rc->lco].insert(q->rc->maxl);
		q->stein[p->lco].erase(q->stein[p->lco].find(p->maxl));
		(q->rc=p)->fa=q;p->path_fa=0;q->update();
		splay(p);
	}
}
void dfs(int u){
	pos[u]=tail++;
	pos[u]->id=u;pos[u]->stein[0].insert(INF);pos[u]->stein[1].insert(INF);
	for(Edge *p=g[u];p;p=p->nxt) if(!pos[p->v])
		dfs(p->v),pos[p->v]->path_fa=pos[u],pos[u]->stein[pos[p->v]->lco].insert(pos[p->v]->maxl);
	pos[u]->update();
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;scanf("%d%d",&u,&v);
		make_edge(u,v);
	}
	for(int i=1;i<=n;i++) scanf("%d",&col[i]);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	dfs(1);scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int op,u,dt;
		scanf("%d%d",&op,&u);
		if(op==0) expose(u),printf("%d\n",pos[u]->maxr);
		else if(op==1) expose(u),col[u]=!col[u],pos[u]->update();
		else scanf("%d",&dt),expose(u),w[u]=dt,pos[u]->update();
	}
	return 0;
}
```

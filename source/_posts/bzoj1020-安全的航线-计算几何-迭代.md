title: bzoj1020 安全的航线 计算几何 迭代
date: 2014-09-09 23:49:52
tags: [计算几何,省选题,迭代法,bzoj]
---

给定c个不自交且互不相交的多边形和一条有n的顶点的折线段。问这条折线上离所有多边形的最小距离的最大值是多少。
当然可以二分答案，然后就变成c个会自交，顶点处带圆弧的多边形能否覆盖这条折线段了。但这么做的编程复杂度太大，再加上c++的不算好的精度，做起来太烦了。
之后参考了2010年国家集训队作业（链接见[这里](http://pan.baidu.com/s/1bn6IxJp)）莫队的《迭代思想的运用》。这里简述一下算法：
1. 初始化孤地点可能位于的线段集合为整条航线。
2. 对于长L的某条线段，左端点与陆地的最近点为$P_1$，右端点与陆地的最近点为$P_2$，那么该线段上的孤地距离将受$P_1$与$P_2$影响。具体来说，利用二分求出该线段上的点P使得$Minimize$ $\gamma = max(Dis(P,P_1),Dis(P,P_2))$
若小于已有的最优答案，那么可以删除该线段。
3. 取所有线段的中点更新答案。
4. 将所有线段从中点分成左右两条线段。
5. 不断进行2，3，4直到线段的集合为空。
这个算法具体的时间复杂度基本上很难估计，但实际效果很好。不过实现起来也不算容易。
终于算是有一个能用的计算几何的template了。
<!--more-->
```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <queue>

using namespace std;

const double eps = 1e-16;

inline int sgn(double a){return a>eps ? 1 : a<-eps ? -1 : 0;}

struct Point{
	double x,y;
	Point() {}
	Point(double _x,double _y) : x(_x), y(_y) {}
	double len(){return sqrt(x*x+y*y);}
};

inline Point operator -(const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}
inline Point operator +(const Point &a,const Point &b){return Point(a.x+b.x,a.y+b.y);}
inline Point operator *(const Point &a,double b){return Point(a.x*b,a.y*b);}
inline Point operator *(double b,const Point &a){return Point(a.x*b,a.y*b);}
inline double operator *(const Point &a,const Point &b){return a.x*b.x+a.y*b.y;} //dot product
inline double operator %(const Point &a,const Point &b){return a.x*b.y-a.y*b.x;} //cross product
inline bool operator ==(const Point &a,const Point &b){return !sgn(a.x-b.x) && !sgn(a.y-b.y);}

#define Vector Point

Vector Normal(const Vector &a){return Vector(-a.y,a.x);} //counterclockwise rotate vector A by 90 degrees

struct Seg{
	Point a,b;
	Seg() {}
	Seg(const Point &_a,const Point &_b) : a(_a), b(_b) {}
};

const int MaxP = 35;
struct Polygon{
	Point p[MaxP];
	int cnt;
};

Point getPoint(const Point &a,const Vector &b,const Point &c,const Vector &d){
	Vector u=a-c;
	double t=(d%u)/(b%d);
	return a+b*t;
}
inline bool is_on(const Point &a,const Point &b,const Point &c){return !sgn((b-a)%(c-a)) && sgn((a.x-b.x)*(a.x-c.x))<=0 && sgn((a.y-b.y)*(a.y-c.y))<=0;}
inline bool is_cross(const Point &a,const Point &b,const Point &c,const Point &d){return sgn(((c-a)%(b-a))*((d-a)%(b-a)))<=0 && sgn(((a-c)%(d-c))*((b-c)%(d-c)))<=0;}
inline bool is_in(const Point &a,const Polygon &b){
	int tot=0;
	for(int i=1;i<=b.cnt;i++)
		if(is_on(a,b.p[i],b.p[i%b.cnt+1]))
			return 1;
	Point Ray(-1e4-1,a.y+0.1),ta(a.x,a.y+0.1);
	for(int i=1;i<=b.cnt;i++)
		if(is_cross(Ray,ta,b.p[i],b.p[i%b.cnt+1]))
			tot++;
	return tot&1;
}

/*----------------------------Template Over-----------------------------*/

const int MaxN = 25;

double ans;
int n,m;
Point plist[MaxN];
Polygon list[MaxN];

struct TMP{
	Point p;
	double d;
	TMP() {}
	TMP(const Point &_p,double _d) : p(_p),d(_d) {}
};

TMP DISPS(const Point &a,const Point &b,const Point &c){
	if(b==c) return TMP(b,(b-a).len());
	Vector v1=c-b,v2=a-b,v3=a-c;
	if(sgn(v1*v2)<=0) return TMP(b,v2.len());
	if(sgn(v1*v3)>=0) return TMP(c,v3.len());
	Point res=getPoint(a,Normal(b-c),b,v1);
	return TMP(res,(a-res).len());
}

inline bool check(const Point &p){
	for(int i=1;i<=n;i++)
		if(is_in(p,list[i]))
			return 1;
	return 0;
}

TMP Find(const Point &p){
	if(check(p)) return TMP(p,0);
	TMP anst;anst.d=1e11;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=list[i].cnt;j++){
			TMP t=DISPS(p,list[i].p[j],list[i].p[j%list[i].cnt+1]);
			if(sgn(anst.d-t.d)>=0) anst=t;
		}
	ans=max(ans,anst.d);
	return anst;
}

void calc(){
	queue<Seg> q;
	for(int i=1;i<m;i++) q.push(Seg(plist[i],plist[i+1])),Find(plist[i]);
	Find(plist[m]);
	while(!q.empty()){
		Seg t=q.front();q.pop();
		Point p1=Find(t.a).p,p2=Find(t.b).p,l=t.a,r=t.b,mid=(l+r)*.5;
		while((r-l).len()>1e-4){
			Point mid=(l+r)*.5;
			if((mid-p1).len()<(mid-p2).len()) l=mid;
			else r=mid;
		}
		double na=max((l-p1).len(),(l-p2).len());
		Find(l);
		if(ans+0.005<na) q.push(Seg(t.a,mid)),q.push(Seg(mid,t.b));
	}
}

void init(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%lf%lf",&plist[i].x,&plist[i].y);
	for(int i=1;i<=n;i++){
		scanf("%d",&list[i].cnt);
		for(int j=1;j<=list[i].cnt;j++) scanf("%lf%lf",&list[i].p[j].x,&list[i].p[j].y);
	}
}

int main()
{
	init();calc();printf("%.2lf\n",ans);
	return 0;
}
```

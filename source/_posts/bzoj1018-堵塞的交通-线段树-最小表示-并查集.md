title: bzoj1018 堵塞的交通 线段树 最小表示法 并查集
date: 2014-09-08 22:09:28
tags: [数据结构,省选题,bzoj,最小表示法]
---

对于一张2×n的网格图，要求你动态维护它的连通性。
这显然可以转化成线段树套并查集，修改边的时候直接暴力重构并查集。
然后就T了。。。应该是暴力重构太暴力了。
把线段树中的并查集部分换成最小表示，然后只有重构的时候要用到并查集了，并且这样做比较规整，用不着特判一些边界情况。
不过这样还是很慢。。2000ms+。递归式线段树常数不小，特别是这里返回的是一个`struct`。

<!--more-->

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int MaxN = 100010;

struct Pack{
	int a[4];
	Pack() {}
	Pack(int _0,int _1,int _2,int _3){a[0]=_0,a[1]=_1,a[2]=_2,a[3]=_3;}
	int query(int u,int v){return a[u]==a[v];}
	void std(){
		int cnt=0,b[6]={-1,-1,-1,-1,-1,-1};
		for(int i=0;i<4;i++) a[i]=(~b[a[i]] ? b[a[i]] : b[a[i]]=cnt++);
	}
};

Pack tmpl[8]={
	Pack(0,1,2,3),Pack(0,1,0,2),Pack(0,1,2,1),Pack(0,1,0,1),Pack(0,0,1,2),Pack(0,0,0,1),Pack(0,0,1,0),Pack(0,0,0,0)
};

struct Set{
	int fa[6];
	void init(){for(int i=0;i<6;i++) fa[i]=i;}
	int getfa(int u){return fa[u]==u ? u : fa[u]=getfa(fa[u]);}
	void join(int u,int v){fa[getfa(u)]=getfa(v);}
	int query(int u,int v){return getfa(u)==getfa(v);}
};

int flag[MaxN];

inline Pack merge(const Pack &a,const Pack &b){
	static Set c;
	static Pack t;
	c.init();
	for(int i=0;i<4;i++) for(int j=i+1;j<4;j++) if(a.a[i]==a.a[j]) c.join(i,j); 
	for(int i=0;i<4;i++) for(int j=i+1;j<4;j++) if(b.a[i]==b.a[j]) c.join(i+2,j+2);
	t=Pack(c.getfa(0),c.getfa(1),c.getfa(4),c.getfa(5));t.std();
	return t;
}

struct Node{
	Pack data;
	int l,r,mid;
	Node *lc,*rc;
	void update(){data=merge(lc->data,rc->data);}
}pool[MaxN << 1],*tail=pool,*rt;

int n;

void build(Node *&rt,int l,int r){
	rt=tail++;rt->l=l;rt->r=r;rt->mid=l+r >> 1;
	if(l==r) rt->data=tmpl[flag[l]];
	else{
		int mid=l+r >> 1;
		build(rt->lc,l,mid);
		build(rt->rc,mid+1,r);
		rt->update();
	}
}

Pack query(Node *rt,int l,int r){
	if(l>r) return tmpl[3];
	if(l<=rt->l && r>=rt->r) return rt->data;
	else{
		int mid=rt->mid;
		if(r<=mid) return query(rt->lc,l,r);
		else if(l>mid) return query(rt->rc,l,r);
		else return merge(query(rt->lc,l,r),query(rt->rc,l,r));
	}
}

void modify(Node *rt,int pos,int t){
	if(rt->l==rt->r) rt->data=tmpl[flag[pos]^=t];
	else{
		int mid=rt->mid;
		if(pos<=mid) modify(rt->lc,pos,t);
		else modify(rt->rc,pos,t);
		rt->update();
	}
}

char op[5];

int main()
{
	scanf("%d",&n);
	build(rt,1,n);
	for(;scanf("%s",op) && op[0]!='E';){
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		if(y1>y2 || y1==y2 && x1>x2) swap(x1,x2),swap(y1,y2);
		if(op[0]=='O' || op[0]=='C') modify(rt,y1,y1==y2 ? 4 : x1);
		else {
			Pack left_col=query(rt,1,y1-1),
				 col=query(rt,y1,y2-1),
				 right_col=query(rt,y2,n);
			if(left_col.query(2,3)) col=merge(tmpl[7],col);
			if(right_col.query(0,1)) col=merge(col,tmpl[7]);
			puts(col.query(x1-1,x2+1) ? "Y" : "N");
		}
	}
	return 0;
}
```

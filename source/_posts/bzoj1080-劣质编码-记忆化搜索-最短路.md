title: bzoj1080 劣质编码 记忆化搜索 最短路
date: 2014-09-30 23:27:34
tags: [bzoj,图论,记忆化搜索]
---

首先排除掉有空串的情况，这时答案一定是0。接下来，题目可以这样来看：给定n个模板串$s_1$,$s_2$,$\dots$,$s_n$，求一个最短的01序列，使得这一序列能被"($s_1$|$s_2$|$\dots$|$s_n$)+"这个正则表达式所代表的NFA以三条不同的路径被接受。

最简单的想法是搞出NFA，用一个四元组(a,b,c,d)来表示第一条路径走到a状态，第二条路径走到b状态，第三条路径走到c状态，且这三条路径两两之间是否相同。最后一个用状压的方式保存在d中。之后通过暴力向后移动一个字符的方式来求出四元组之间的转移关系，然后就变成求从初状态到末状态的最短路了。

现在的问题是将图建起来——因为这张图显然是有环的，没办法使用普通的dp来解决。但这一方法很难实现，因为点数太大，最多有$1500^3×5$种不同的四元组。考虑对这一方法进行优化。

我们称NFA中有分支的点为“分歧点”。可以看到，这样的分歧点只有可能是NFA的起始态和接受态。因此我们可以考虑以整个串而非单个字符为单位进行移动。

（NOTE：从同步变成异步。）

那么如何来表示状态呢？使用最小表示法。我们可以看到，任一时刻，一定有一个最长路径，且(1)另两条路径所代表的字符串是这一最长路径的前缀，并且(2)这三条路径的尾指针可以看做是指在同一字符串内的！因为如果不满足条件(1)，那么这一状态就不合法，如果不满足条件(2)，就可以在较短的两个串后面添加一些串使它满足条件(2)，或干脆无法满足目标。于是对于这三条路径，我们可以用(a,b,c,d)来表示，a表示三个串中最长的一个的末尾串编号，b表示第二长的串的尾指针位置，c表示第三长的串的尾指针位置。d=0时最长串和第二长串相同；d=1时第二长串和第三长串相同；d=2时三个串各不相同。然后可以得到它们之间的相互转化关系。

这样总点数至多为$30×50×50×3$，可以承受。至于边数，由于此处合法转移不会很多，并且会掉入循环之中，因此边数看起来也不会特别大。这里要使用记忆化搜索的方式来建图和对节点进行标号。

自古~~弱省~~省选多神题T T。这题被CLJ等人以暴力高速水过什么的，简直是丧心病狂。。

<!--more-->

```c++
//Lost in the void...
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <string>
#include <queue>

using namespace std;

const int MaxN = 35*35*55*4;
const int INF = 0x3f3f3f3f;

struct Node{
	int v,c;
	Node *nxt;
	Node (){}
	Node (int _v,int _c,Node *_nxt) : v(_v),c(_c),nxt(_nxt) {};
}*g[MaxN];

int n;
char list[35][55];
int len[35];
int num[35];
int f[35][55][55][3];
int S,T,lst;
int d[MaxN],inq[MaxN];

inline bool cmp(int a,int b){return len[a]>len[b];}
inline bool check(char *a,int stpos,char *b,int len){
	for(int i=0;i<len;i++) if(!a[i+stpos] || !b[i+1] || a[i+stpos]!=b[i+1]) return 0;
	return 1;
}
inline void make_edge(int u,int v,int c){g[u]=new Node(v,c,g[u]);}
inline bool ckmin(int &a,int b){return b<a ? a=b,1 : 0;}
inline void getline(char *a){string t;cin >> t;strcpy(a,t.c_str());}

int init(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		getline(list[i]+1);
		if(!(len[i]=strlen(list[i]+1))){puts("0");return 1;}
		num[i]=i;
	}
	sort(num+1,num+1+n,cmp);
	return 0;
}

int dfs(int a,int b,int c,int st){
	if(f[a][b][c][st]) return f[a][b][c][st];
	f[a][b][c][st]=++lst;
	int nl=len[a],nn=f[a][b][c][st];
	if(st==0){
		for(int i=1;i<=n;i++)
			if(len[i]+c<=nl && check(list[a],c+1,list[i],len[i]))
				make_edge(nn,dfs(a,b,c+len[i],0),len[i]);
			else if(len[i]+c>nl && check(list[a],c+1,list[i],nl-c))
				make_edge(nn,dfs(i,b-c,b-c,1),nl-c);
	}
	else if(st==1){
		for(int i=1;i<=n;i++)
			if(len[i]+c<=nl && check(list[a],c+1,list[i],len[i]))
				make_edge(nn,dfs(a,b+len[i],c+len[i],1),len[i]);
			else if(len[i]+c>nl && check(list[a],c+1,list[i],nl-c))
				make_edge(nn,dfs(i,len[i],nl-c,0),nl-c);
		for(int p=1,i=num[p];p<=n;i=num[++p])
			for(int q=p+1,j=num[q];q<=n;j=num[++q]){
				if(len[i]+b<=nl && check(list[a],b+1,list[i],len[i]) && check(list[a],c+1,list[j],len[j]))
					make_edge(nn,dfs(a,b+len[i],c+len[j],2),len[j]);
				else if(len[i]+b>nl && len[j]+c<=nl && check(list[a],b+1,list[i],nl-b) && check(list[a],c+1,list[j],len[j]))
					make_edge(nn,dfs(i,nl-b,len[j],2),len[j]);
				else if(len[i]+b>nl && len[j]+c>nl && check(list[a],b+1,list[i],nl-b) && check(list[a],c+1,list[j],nl-c) && check(list[i],1,list[j],len[j]))
					make_edge(nn,dfs(i,len[j],nl-c,2),nl-c);
			}
	}
	else{
		if(b==nl && c==nl) make_edge(nn,T,0);
		for(int i=1;i<=n;i++)
			if(len[i]+c<=b && check(list[a],c+1,list[i],len[i]))
				make_edge(nn,dfs(a,b,c+len[i],2),len[i]);
			else if(len[i]+c>b && len[i]+c<=nl && check(list[a],c+1,list[i],len[i]))
				make_edge(nn,dfs(a,c+len[i],b,2),b-c);
			else if(len[i]+c>nl && check(list[a],c+1,list[i],nl-c))
				make_edge(nn,dfs(i,nl-c,b-c,2),b-c);
	}
	return nn;
}

int spfa(){
	queue<int> q;
	memset(d,0x3f,sizeof(d));
	d[S]=0;inq[S]=1;q.push(S);
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		for(Node *p=g[u];p;p=p->nxt)
			if(ckmin(d[p->v],d[u]+p->c) && !inq[p->v])
				inq[p->v]=1,q.push(p->v);
	}
	return d[T];
}

void work(){
	S=0,T=1,lst=1;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(check(list[num[i]],1,list[num[j]],len[num[j]]))
				make_edge(S,dfs(num[i],len[num[i]],len[num[j]],0),len[num[j]]),
				make_edge(S,dfs(num[i],len[num[j]],len[num[j]],1),len[num[j]]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++) if(check(list[num[i]],1,list[num[j]],len[num[j]]))
			for(int k=j+1;k<=n;k++) if(check(list[num[j]],1,list[num[k]],len[num[k]]))
				make_edge(S,dfs(num[i],len[num[j]],len[num[k]],2),len[num[k]]);
	int res=spfa();
	printf("%d\n",res>=INF ? -1 : res);
}
int main()
{
	if(!init()) work();
	return 0;
}
```
